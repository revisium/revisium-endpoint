# Generated GraphQL Schema Structure

This document details the structure of the GraphQL schemas generated by the system, including all automatically generated types, fields, and conventions.

## Table of Contents

- [Overview](#overview)
- [Naming Conventions](#naming-conventions)
- [Core Generated Types](#core-generated-types)
- [System Fields](#system-fields)
- [System Types](#system-types)
- [Query Structure](#query-structure)
- [Type Relationships](#type-relationships)
- [Ordering Limitations](#ordering-limitations)

## Overview

For each table in your database, the system generates a comprehensive set of GraphQL types that follow GraphQL and Relay conventions. The generated schema includes:

1. **Entity Types**: Represent the core data structure of your table
2. **Node Types**: Extend entity types with metadata fields (system fields)
3. **Flat Types**: Simplified versions without metadata
4. **Connection Types**: Implement the Relay pagination specification
5. **Edge Types**: Connect entities to cursors for pagination
6. **Input Types**: For filtering, sorting, and querying
7. **System Types**: Shared types used across all tables

## Naming Conventions

All generated types follow consistent naming conventions that can be customized through configuration:

### Base Naming

For a table named `user` in a project named `MyProject`:

```
MyProjectUser          # Base entity type
MyProjectUserNode      # Node type (with postfix)
MyProjectUserFlat      # Flat type (with postfix)
```

### Connection and Edge Naming

```
MyProjectUserConnection   # Connection type
MyProjectUserEdge         # Edge type
MyProjectUserFlatConnection # Flat connection type
MyProjectUserFlatEdge     # Flat edge type
```

### Input Type Naming

```
MyProjectGetUserInput         # Input for list queries
MyProjectGetUserOrderByInput  # Input for ordering
MyProjectUserWhereInput       # Input for filtering
```

### System Type Naming

```
MyProjectPageInfo        # Pagination info
MyProjectSortOrder       # Sort direction enum
MyProjectStringFilter    # String filter input
MyProjectBoolFilter      # Boolean filter input
MyProjectDateTimeFilter  # DateTime filter input
MyProjectJsonFilter      # JSON filter input
```

## Core Generated Types

### Entity Types

Entity types represent the core data structure of your table and contain only the fields defined in your JSON schema:

```graphql
type MyProjectUser {
  name: String!
  email: String!
  age: Int
  active: Boolean!
}
```

### Node Types

Node types extend entity types with system metadata fields. These are available when `GRAPHQL_HIDE_NODE_TYPES` is not set to true:

```graphql
type MyProjectUserNode {
  createdAt: DateTime!
  createdId: String!
  data: MyProjectUser!
  id: String!
  json: JSON!
  publishedAt: DateTime!
  updatedAt: DateTime!
  versionId: String!
}
```

Node types are useful when you need access to system metadata about entities, such as creation timestamps, version information, and raw JSON data.

### Flat Types

Flat types provide a simplified view of the data without metadata. These are available when `GRAPHQL_HIDE_FLAT_TYPES` is not set to true:

```graphql
type MyProjectUserFlat {
  name: String!
  email: String!
  age: Int
  active: Boolean!
}
```

Flat types are useful when you only need the core data fields and want to avoid the overhead of system metadata.

### Connection Types

Connection types implement the Relay pagination specification:

```graphql
type MyProjectUserConnection {
  edges: [MyProjectUserEdge!]!
  pageInfo: MyProjectPageInfo!
  totalCount: Int!
}
```

### Edge Types

Edge types connect entities to cursors for pagination:

```graphql
type MyProjectUserEdge {
  cursor: String!
  node: MyProjectUserNode!
}

type MyProjectUserFlatEdge {
  cursor: String!
  node: MyProjectUserFlat!
}
```

## System Fields

Node types contain several system fields that provide metadata about each entity:

| Field | Type | Description |
|-------|------|-------------|
| `id` | `String!` | Unique identifier for the entity |
| `createdAt` | `DateTime!` | Timestamp when the entity was created |
| `createdId` | `String!` | ID of the user who created the entity |
| `updatedAt` | `DateTime!` | Timestamp when the entity was last updated |
| `publishedAt` | `DateTime!` | Timestamp when the entity was published |
| `versionId` | `String!` | Version identifier for the entity |
| `json` | `JSON!` | Raw JSON representation of the entity data |
| `data` | `EntityType!` | The actual entity data |

Flat types do not contain any system fields - they only contain the data fields defined in your JSON schema.

## System Types

### PageInfo

Provides pagination information:

```graphql
type MyProjectPageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}
```

### SortOrder

Enum for sort direction:

```graphql
enum MyProjectSortOrder {
  asc
  desc
}
```

### Filter Types

Input types for filtering by different data types:

#### String Filter

```graphql
input MyProjectStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: MyProjectFilterStringMode
  not: String
  notIn: [String!]
  startsWith: String
}

enum MyProjectFilterStringMode {
  default
  insensitive
}
```

#### Boolean Filter

```graphql
input MyProjectBoolFilter {
  equals: Boolean
  not: Boolean
}
```

#### DateTime Filter

```graphql
input MyProjectDateTimeFilter {
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  notIn: [String!]
}
```

#### JSON Filter

```graphql
input MyProjectJsonFilter {
  array_contains: [JSON!]
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  mode: MyProjectFilterJsonMode
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

enum MyProjectFilterJsonMode {
  default
  insensitive
}
```

### OrderBy Types

Input types for specifying sort fields (currently limited to system fields only):

```graphql
enum MyProjectGetUserOrderByField {
  createdAt
  id
  publishedAt
  updatedAt
}

input MyProjectGetUserOrderByInput {
  direction: MyProjectSortOrder!
  field: MyProjectGetUserOrderByField!
}
```

### Where Input Types

Composite input types for complex filtering:

```graphql
input MyProjectUserWhereInput {
  AND: [MyProjectUserWhereInput!]
  NOT: [MyProjectUserWhereInput!]
  OR: [MyProjectUserWhereInput!]
  createdAt: MyProjectDateTimeFilter
  createdId: MyProjectStringFilter
  data: MyProjectJsonFilter
  id: MyProjectStringFilter
  publishedAt: MyProjectDateTimeFilter
  readonly: MyProjectBoolFilter
  updatedAt: MyProjectDateTimeFilter
  versionId: MyProjectStringFilter
}
```

## Query Structure

The generated schema includes a comprehensive set of queries for each table:

### Single Entity Queries

```graphql
type Query {
  user(id: String!): MyProjectUserNode!
  userFlat(id: String!): MyProjectUserFlat!
}
```

### List Queries

```graphql
type Query {
  users(data: MyProjectGetUserInput): MyProjectUserConnection!
  usersFlat(data: MyProjectGetUserInput): MyProjectUserFlatConnection!
}
```

### Query Input Structure

```graphql
input MyProjectGetUserInput {
  after: String
  first: Int
  orderBy: [MyProjectGetUserOrderByInput!]
  where: MyProjectUserWhereInput
}
```

## Type Relationships

The system automatically generates relationships based on foreign key definitions in the JSON schemas.

When your JSON schema contains foreign key references, the system automatically creates resolvers that can fetch the related entities.



### Relationship Resolution Examples

```graphql
query GetUserWithProfile {
  user(id: "user-123") {
    id
    data {
      name
      # Automatically resolved relationship
      profile {
        id
        data {
          bio
          avatarUrl
        }
      }
    }
  }
}

query GetUserWithPosts {
  user(id: "user-123") {
    id
    data {
      name
      # Automatically resolved relationship
      posts {
        edges {
          node {
            id
            data {
              title
              content
            }
          }
        }
      }
    }
  }
}
```

## Ordering Limitations

Currently, ordering (sorting) only works with system fields. You can sort by:

- `createdAt`
- `id`
- `publishedAt`
- `updatedAt`

Example of valid ordering:

```graphql
query GetUsersSorted {
  users(data: {
    orderBy: [
      {
        field: createdAt
        direction: desc
      }
    ]
  }) {
    edges {
      node {
        id
        createdAt
        data {
          name
        }
      }
    }
    totalCount
  }
}
```

Sorting by custom fields from your data schema is not currently supported but will be added in a future release.